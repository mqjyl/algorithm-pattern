# å›¾

å›¾ä¸­çš„æ¦‚å¿µå¾ˆå¤šï¼ŒåŒ…æ‹¬æœ‰å‘å›¾å’Œæ— å‘å›¾ã€å®Œå…¨å›¾å’Œæœ‰å‘å®Œå…¨å›¾ã€ç¨€ç–å›¾å’Œç¨ å¯†å›¾ã€å…¥åº¦å’Œå‡ºåº¦ã€è·¯å¾„å’Œç®€å•è·¯å¾„ã€å›è·¯ï¼ˆç¯ï¼‰ã€ï¼ˆå¼ºï¼‰è¿é€šå›¾å’Œï¼ˆå¼ºï¼‰è¿é€šåˆ†é‡ã€ç”Ÿæˆæ ‘å’Œç”Ÿæˆæ£®æ—ç­‰ï¼Œè¿˜æœ‰å“ˆå¯†é¡¿å›¾ã€æ¬§æ‹‰å›¾ç­‰åˆç‰¹æ®Šæ€§è´¨çš„å›¾ã€‚é¢è¯•ä¸­è€ƒæ ¸çš„æ˜¯ä¸¤ç§æœç´¢ç®—æ³•ï¼šæ·±åº¦ä¼˜å…ˆæœç´¢å’Œå¹¿åº¦ä¼˜å…ˆæœç´¢ã€‚

## âœ ä¸€ã€å›¾çš„å­˜å‚¨ç»“æ„

å›¾æ˜¯ç”± $$(V,E)$$ æ¥è¡¨ç¤ºçš„ï¼Œå¯¹äºæ— å‘å›¾æ¥è¯´ï¼Œå…¶ä¸­ $$V=(v_0, v_1, \ldots, v_n)$$ ï¼Œ $$E=\{ (v_i, v_j)(0\le i,j \le n\text{ä¸”}i\text{ä¸ç­‰äº}j)\}$$ ï¼Œå¯¹äºæœ‰å‘å›¾ï¼Œ $$E=\{<v_i, v_j>(0 \le i, j \le n\text{ä¸”}i\text{ä¸ç­‰äº}j)\}$$ ã€‚**V**æ˜¯é¡¶ç‚¹çš„é›†åˆï¼Œ**E**æ˜¯è¾¹çš„é›†åˆã€‚

### ğŸ–‹ 1ã€é‚»æ¥çŸ©é˜µ

![](../.gitbook/assets/91.png)

![](../.gitbook/assets/92.png)

* æ— å‘å›¾çš„é‚»æ¥çŸ©é˜µæ˜¯å¯¹ç§°çŸ©é˜µï¼Œnä¸ªé¡¶ç‚¹çš„æ— å‘å›¾éœ€è¦ $$n\times(n+1)/2$$ ä¸ªç©ºé—´å¤§å°
* æœ‰å‘å›¾çš„é‚»æ¥çŸ©é˜µä¸ä¸€å®šå¯¹ç§°ï¼Œnä¸ªé¡¶ç‚¹çš„æœ‰å‘å›¾éœ€è¦ $$n^2$$ çš„å­˜å‚¨ç©ºé—´
* æ— å‘å›¾ä¸­ç¬¬ i è¡Œçš„éé›¶å…ƒç´ çš„ä¸ªæ•°ä¸ºé¡¶ç‚¹ $$V_i$$ çš„åº¦
* æœ‰å‘å›¾ä¸­ç¬¬ i è¡Œçš„éé›¶å…ƒç´ çš„ä¸ªæ•°ä¸ºé¡¶ç‚¹ $$V_i$$ çš„å‡ºåº¦ï¼Œç¬¬ i åˆ—çš„éé›¶å…ƒç´ çš„ä¸ªæ•°ä¸ºé¡¶ç‚¹ $$V_i$$ çš„å…¥åº¦

### ğŸ–‹ 2ã€é‚»æ¥è¡¨

![](../.gitbook/assets/93.png)

* æ— å‘å›¾é¡¶ç‚¹ Vi çš„åº¦ä¸ºç¬¬ i ä¸ªå•é“¾è¡¨ä¸­çš„ç»“ç‚¹æ•°
* æ— å‘å›¾ä¸­é¡¶ç‚¹ Vi çš„å‡ºåº¦ä¸ºç¬¬ i ä¸ªå•é“¾è¡¨ä¸­çš„ç»“ç‚¹ä¸ªæ•°ï¼Œé¡¶ç‚¹ Vi çš„å…¥åº¦ä¸ºå…¨éƒ¨å•é“¾è¡¨ä¸­è¿æ¥ç‚¹åŸŸå€¼æ˜¯ i çš„ç»“ç‚¹ä¸ªæ•°
* é€†é‚»æ¥è¡¨ï¼šæœ‰å‘å›¾ä¸­å¯¹æ¯ä¸ªç»“ç‚¹å»ºç«‹ä»¥ Vi ä¸ºå¤´çš„å¼§çš„å•é“¾è¡¨

#### é‚»æ¥çŸ©é˜µå’Œé‚»æ¥è¡¨

1. åœ¨è¾¹ç¨€ç–ï¼ˆ $$e << n\times(n+1)/2$$ ï¼‰çš„æƒ…å†µä¸‹ï¼Œç”¨é‚»æ¥è¡¨è¡¨ç¤ºå›¾æ¯”é‚»æ¥çŸ©é˜µèŠ‚çœå­˜å‚¨ç©ºé—´ï¼Œå½“ä¸è¾¹ç›¸å…³çš„ä¿¡æ¯è¾ƒå¤šæ—¶æ›´æ˜¯å¦‚æ­¤ 
2. åœ¨é‚»æ¥è¡¨ä¸Šå®¹æ˜“æ‰¾åˆ°ä»»ä½•ä¸€é¡¶ç‚¹çš„ç¬¬ä¸€ä¸ªé‚»æ¥ç‚¹å’Œä¸‹ä¸€ä¸ªé‚»æ¥ç‚¹ï¼Œä½†è¦åˆ¤å®šä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ï¼ˆ $$v$$ å’Œ $$v_1$$ ï¼‰ä¹‹é—´æ˜¯å¦æœ‰è¾¹æˆ–å¼§ç›¸è¿ï¼Œåˆ™éœ€æœç´¢ç¬¬ i ä¸ªæˆ–ç¬¬ j ä¸ªé“¾è¡¨ï¼Œå› æ­¤ï¼Œä¸åŠé‚»æ¥çŸ©é˜µæ–¹ä¾¿ã€‚ 
3. é‚»æ¥è¡¨é€‚åˆå­˜æ— å‘å›¾

### ğŸ–‹ 3ã€åå­—é“¾è¡¨

è¾¹ç»“ç‚¹å’Œé¡¶ç‚¹ç»“ç‚¹å¦‚ä¸‹ç¤ºï¼š

![](../.gitbook/assets/98.png)

å…¶ä¸­`tailvex`æ˜¯æŒ‡å¼§èµ·ç‚¹åœ¨é¡¶ç‚¹è¡¨çš„ä¸‹æ ‡ï¼Œ`headvex`æ˜¯æŒ‡å¼§ç»ˆç‚¹åœ¨é¡¶ç‚¹è¡¨çš„ä¸‹æ ‡ã€‚ `headlink`æ˜¯æŒ‡å…¥è¾¹è¡¨æŒ‡é’ˆåŸŸï¼ŒæŒ‡å‘ç»ˆç‚¹ç›¸åŒçš„ä¸‹ä¸€æ¡è¾¹ï¼Œ`taillink`æ˜¯æŒ‡è¾¹è¡¨æŒ‡é’ˆåŸŸï¼ŒæŒ‡å‘èµ·ç‚¹ç›¸åŒçš„ä¸‹ä¸€æ¡è¾¹ã€‚ å¦‚æœæ˜¯ç½‘ï¼Œæˆ‘ä»¬è¿˜è¦åœ¨å…¶ä¸­åŠ å…¥æƒå€¼åŸŸï¼Œæ¥å­˜å‚¨æƒå€¼ã€‚

![](../.gitbook/assets/99.png)

`firstin`è¡¨ç¤ºå…¥è¾¹è¡¨å¤´æŒ‡é’ˆï¼ŒæŒ‡å‘è¯¥é¡¶ç‚¹çš„å…¥è¾¹è¡¨ä¸­ç¬¬ä¸€ä¸ªç»“ç‚¹ã€‚ `firstout`è¡¨ç¤ºå‡ºè¾¹è¡¨å¤´æŒ‡é’ˆï¼ŒæŒ‡å‘è¯¥é¡¶ç‚¹çš„å‡ºè¾¹è¡¨ä¸­ç¬¬ä¸€ä¸ªç»“ç‚¹ã€‚

![](../.gitbook/assets/95.png)

æ¨ªå‘æ˜¯å‡ºåº¦ï¼Œçºµå‘æ˜¯å…¥åº¦ã€‚

### ğŸ–‹ 4ã€é‚»æ¥å¤šé‡è¡¨

é‚»æ¥å¤šé‡è¡¨çš„ç»“æ„å’Œåå­—é“¾è¡¨ç±»ä¼¼ã€‚è¾¹ç»“ç‚¹å’Œé¡¶ç‚¹ç»“ç‚¹å¦‚ä¸‹ç¤ºï¼š

![](../.gitbook/assets/96.png)

![](../.gitbook/assets/97.png)

è¾¹ç»“ç‚¹ç”±6ä¸ªåŸŸç»„æˆï¼š`mark`ä¸ºæ ‡å¿—åŸŸï¼Œå¯æ ‡è®°è¿™æ¡è¾¹æ˜¯å¦è¢«æœç´¢è¿‡ï¼› `ivex`å’Œ`jvex`ä¸ºè¯¥è¾¹ä¾é™„çš„ä¸¤ä¸ªé¡¶ç‚¹åœ¨å›¾ä¸­çš„ä½ç½®ï¼›`ilink`æŒ‡å‘ä¸‹ä¸€æ¡ä¾é™„äºé¡¶ç‚¹`ivex`çš„è¾¹ï¼›`jlink`æŒ‡å‘ä¸‹ä¸€æ¡ä¾é™„äºé¡¶ç‚¹`jvex`çš„è¾¹ï¼Œ`info`ä¸ºæŒ‡å‘å’Œè¾¹ç›¸å…³çš„å„ç§ä¿¡æ¯çš„æŒ‡é’ˆåŸŸã€‚é¡¶ç‚¹ç»“ç‚¹ç”±2ä¸ªåŸŸç»„æˆï¼š`data`å­˜å‚¨å’Œè¯¥é¡¶ç‚¹ç›¸å…³çš„ä¿¡æ¯å¦‚é¡¶ç‚¹åç§°ï¼›`firstedge`åŸŸæŒ‡ç¤ºç¬¬ä¸€æ¡ä¾é™„äºè¯¥é¡¶ç‚¹çš„è¾¹ã€‚

![](../.gitbook/assets/101.png)

## âœ äºŒã€å›¾çš„éå†

**æ·±åº¦ä¼˜å…ˆæœç´¢æ€æƒ³ï¼š**å‡è®¾åˆå§‹çŠ¶æ€æ˜¯å›¾ä¸­æ‰€æœ‰é¡¶ç‚¹å‡æœªè¢«è®¿é—®ï¼Œåˆ™ä»æŸä¸ªé¡¶ç‚¹ v å‡ºå‘ï¼Œé¦–å…ˆè®¿é—®è¯¥é¡¶ç‚¹ï¼Œç„¶åä¾æ¬¡ä»å®ƒçš„å„ä¸ªæœªè¢«è®¿é—®çš„é‚»æ¥ç‚¹å‡ºå‘æ·±åº¦ä¼˜å…ˆæœç´¢éå†å›¾ï¼Œç›´è‡³å›¾ä¸­æ‰€æœ‰å’Œ v æœ‰è·¯å¾„ç›¸é€šçš„é¡¶ç‚¹éƒ½è¢«è®¿é—®åˆ°ã€‚è‹¥æ­¤æ—¶å°šæœ‰å…¶ä»–é¡¶ç‚¹æœªè¢«è®¿é—®åˆ°ï¼Œåˆ™å¦é€‰ä¸€ä¸ªæœªè¢«è®¿é—®çš„é¡¶ç‚¹ä½œèµ·å§‹ç‚¹ï¼Œé‡å¤ä¸Šè¿°è¿‡ç¨‹ï¼Œç›´è‡³å›¾ä¸­æ‰€æœ‰é¡¶ç‚¹éƒ½è¢«è®¿é—®åˆ°ä¸ºæ­¢ã€‚

 **å¹¿åº¦ä¼˜å…ˆæœç´¢æ€æƒ³ï¼š**ä»å›¾ä¸­æŸé¡¶ç‚¹ v å‡ºå‘ï¼Œåœ¨è®¿é—®äº† v ä¹‹åä¾æ¬¡è®¿é—® v çš„å„ä¸ªæœªæ›¾è®¿é—®è¿‡çš„é‚»æ¥ç‚¹ï¼Œç„¶ååˆ†åˆ«ä»è¿™äº›é‚»æ¥ç‚¹å‡ºå‘ä¾æ¬¡è®¿é—®å®ƒä»¬çš„é‚»æ¥ç‚¹ï¼Œå¹¶ä½¿å¾—â€œå…ˆè¢«è®¿é—®çš„é¡¶ç‚¹çš„é‚»æ¥ç‚¹å…ˆäºåè¢«è®¿é—®çš„é¡¶ç‚¹çš„é‚»æ¥ç‚¹è¢«è®¿é—®ï¼Œç›´è‡³å›¾ä¸­æ‰€æœ‰å·²è¢«è®¿é—®çš„é¡¶ç‚¹çš„é‚»æ¥ç‚¹éƒ½è¢«è®¿é—®åˆ°ã€‚å¦‚æœæ­¤æ—¶å›¾ä¸­å°šæœ‰é¡¶ç‚¹æœªè¢«è®¿é—®ï¼Œåˆ™éœ€è¦å¦é€‰ä¸€ä¸ªæœªæ›¾è¢«è®¿é—®è¿‡çš„é¡¶ç‚¹ä½œä¸ºæ–°çš„èµ·å§‹ç‚¹ï¼Œé‡å¤ä¸Šè¿°è¿‡ç¨‹ï¼Œç›´è‡³å›¾ä¸­æ‰€æœ‰é¡¶ç‚¹éƒ½è¢«è®¿é—®åˆ°ä¸ºæ­¢ã€‚

## âœ ä¸‰ã€å›¾çš„è¿é€šæ€§

### ğŸ–‹ 1ã€æ— å‘å›¾çš„åŒè¿é€šåˆ†é‡

è®¾`G=(V,E)`æ˜¯è¿é€šçš„æ— å‘å›¾ï¼Œå¦‚æœVä¸­é¡¶ç‚¹aæ˜¯ä¸€ä¸ª`å…³èŠ‚ç‚¹`ï¼Œè‹¥ V ä¸­æœ‰é¡¶ç‚¹`v,w`ä½¿å¾—`v,w,a`å„ä¸ç›¸åŒä¸” vå’Œ w ä¹‹é—´çš„æ¯æ¡è·¯éƒ½åŒ…å« aã€‚æ¢è¨€ä¹‹ï¼Œå¦‚æœåˆ é™¤aå’Œä¸ä¹‹ç›¸é‚»çš„æ‰€æœ‰è¾¹æ—¶ï¼Œå°±ä¼šæŠŠå›¾çš„ä¸€ä¸ªè¿é€šåˆ†é‡æ‹†åˆ†æˆå¤šä¸ªè¿é€šåˆ†é‡ã€‚è€Œè‹¥å¯¹Vä¸­æ¯ä¸ªä¸åŒçš„ä¸‰å…ƒç»„`v,w,a`ï¼Œåœ¨vå’Œwä¹‹é—´éƒ½å­˜åœ¨ä¸€æ¡ä¸åŒ…å«açš„è·¯å¾„ï¼Œåˆ™è¯´Gæ˜¯`åŒè¿é€š`çš„ã€‚å› æ­¤ï¼Œä»…å½“ä¸€ä¸ªè¿é€šçš„æ— å‘å›¾æ²¡æœ‰å…³èŠ‚ç‚¹æ—¶ï¼Œå®ƒæ‰æ˜¯åŒè¿é€šçš„ã€‚

è¾¹`e1`å’Œ`e2`ç­‰ä»·ï¼Œè‹¥`e1=e2`æˆ–è€…æœ‰ä¸€æ¡ç¯è·¯æ—¢åŒ…å«`e1`åˆåŒ…å«`e2`ï¼Œåˆ™ç§°è¾¹`e1`å’Œ`e2`æ˜¯ç­‰ä»·çš„ã€‚

å‡è®¾ $$V_i$$ æ˜¯ $$E_i$$ ä¸­å„è¾¹éƒ½å½¼æ­¤è¿æ¥çš„é¡¶ç‚¹é›†\(æˆ–è€…åˆ©ç”¨è¾¹çš„ç­‰ä»·æ€§æ¥åˆ’åˆ†ç­‰ä»·ç±»\)ï¼Œåˆ™æ¯ä¸ªå›¾ $$G_i=(V_i, E_i)$$ å«åš G çš„ä¸€ä¸ª**åŒè¿é€šåˆ†é‡**ã€‚

* åŒè¿é€šåˆ†é‡æ˜¯åŒè¿é€šçš„ï¼›
* å¯¹æ‰€æœ‰çš„ $$i,j$$ \(ä¸ç›¸ç­‰\)ï¼Œ $$V_i$$ å’Œ $$V_j$$ æœ€å¤šä¸€èµ·åŒ…å«ä¸€ä¸ªé¡¶ç‚¹ï¼›
* å½“ä¸”ä»…å½“ v æ˜¯ $$V_i$$ å’Œ $$V_j$$ å…±åŒåŒ…å«çš„é¡¶ç‚¹æ—¶ï¼Œv æ˜¯ G çš„ä¸€ä¸ªå…³èŠ‚ç‚¹ã€‚

#### æ±‚å…³èŠ‚ç‚¹

å‡è®¾å¯¹è¿é€šæ— å‘å›¾Gè¿›è¡Œæ·±åº¦ä¼˜å…ˆæœç´¢å’Œæ·±åº¦ä¼˜å…ˆç¼–å·ï¼Œäº§ç”Ÿæ·±åº¦ä¼˜å…ˆç”Ÿæˆæ ‘ $$S=(V,T)$$ å’Œå›é€€è¾¹ Bã€‚

> æ€§è´¨ï¼šå¦‚æœä¸€ä¸ªé¡¶ç‚¹ v çš„çœŸå­å­™çš„æ‰€æœ‰å›é€€è¾¹éƒ½æŒ‡å‘ v æˆ–è€…æ¯” v æ›´æ·±å±‚æ¬¡\(ç¦»æ ‘æ ¹æ›´è¿œ\)çš„é¡¶ç‚¹ï¼Œåˆ™ v æ˜¯å…³èŠ‚ç‚¹ã€‚è‹¥æœ‰çš„å›é€€è¾¹æŒ‡å‘ v çš„çœŸç¥–å…ˆï¼Œåˆ™ v ä¸æ˜¯å…³èŠ‚ç‚¹ã€‚

ç®—æ³•æ­¥éª¤ï¼š

* å¯¹å›¾è¿›è¡Œæ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œè®¡ç®—æ¯ä¸ªé¡¶ç‚¹vçš„æ·±åº¦ä¼˜å…ˆç¼–å· `dfn[v]`ï¼Œå½¢æˆæ·±åº¦ä¼˜å…ˆç”Ÿæˆæ ‘
* è®¡ç®—æ‰€æœ‰é¡¶ç‚¹ v çš„`low[v]`ç¼–å·æ˜¯åœ¨æ·±åº¦ä¼˜å…ˆç”Ÿæˆæ ‘ä¸ŠæŒ‰åæ ¹éå†é¡ºåºè¿›è¡Œçš„ã€‚`low[v]`å–ä¸‹è¿°ä¸‰å€¼çš„æœ€å°è€…ï¼š
  * `dfn[v]`
  * `dfn[w]`ï¼šå­˜åœ¨å›é€€è¾¹`(v,w)`çš„ä»»ä½•é¡¶ç‚¹ w
  * `low[y]`ï¼šy æ˜¯ v çš„ä»»æ„å„¿å­
* è®¡ç®—å®Œ`low`ç¼–å·åï¼Œæ±‚å…³èŠ‚ç‚¹ï¼Œæ ¹æ®æ€§è´¨ï¼Œå¯çŸ¥ï¼š
  * æ ‘æ ¹åªè¦æœ‰2ä¸ªæˆ–æ›´å¤šçš„å„¿å­ï¼Œå®ƒå°±æ˜¯å…³èŠ‚ç‚¹ï¼Œæ˜¾ç„¶
  * éæ ‘æ ¹é¡¶ç‚¹ v æ˜¯å…³èŠ‚ç‚¹ï¼Œå½“ä¸”ä»…å½“ v æœ‰æŸä¸ªå„¿å­ yï¼Œä½¿`low[y] >= dfn[v]`ï¼Œè¿™é‡Œå…¶å®å°±æ˜¯è¯´å…¶çœŸå­å­™çš„å›é€€è¾¹éƒ½æŒ‡å‘ v æˆ–è€…æ¯” v æ›´æ·±å±‚æ¬¡çš„é¡¶ç‚¹

### ğŸ–‹ 2ã€æœ‰å‘å›¾çš„å¼ºè¿é€šåˆ†é‡

æœ‰å‘å›¾çš„ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡æ˜¯è¯¥å›¾ä¸­é¡¶ç‚¹çš„ä¸€ä¸ªæœ€å¤§å­é›†ï¼šå…¶ä¸­çš„ä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ x å’Œ yï¼Œå­˜åœ¨ x åˆ° y çš„è·¯å¾„ï¼Œä¹Ÿå­˜åœ¨ y åˆ° x çš„è·¯å¾„ã€‚ä»¤ $$G=(V,E)$$ æ˜¯ä¸€ä¸ªæœ‰å‘å›¾ï¼Œå°†Våˆ†å‰²æˆè‹¥å¹²ç­‰ä»·ç±» $$V_i(l<=i<=r)$$ ï¼Œä½¿å¾— $$V_i$$ ä¸­çš„ v å’Œ w ç­‰ä»·çš„å……è¦æ¡ä»¶æ˜¯æœ‰ä¸€æ¡è·¯å¾„ä» v åˆ° wï¼Œä¹Ÿå­˜åœ¨ä¸€æ¡è·¯å¾„ä» w åˆ° vã€‚ä»¤ $$E_i(l\le i\le r)$$ æ˜¯å¤´ã€å°¾å‡åœ¨ $$V_i$$ çš„è¾¹é›†ï¼Œåˆ™ $$G_i=(V_i, E_i)$$ æ˜¯ G çš„**å¼ºè¿é€šåˆ†é‡**ï¼Œç®€ç§°å¼ºåˆ†é‡ã€‚æŠŠåªå…·æœ‰ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡çš„æœ‰å‘å›¾ç§°ä¸º**å¼ºè¿é€šå›¾**ã€‚

è¿æ¥ä¸¤ä¸ªå¼ºåˆ†é‡çš„è¾¹å«åš`åˆ†æ”¯æ¨ªè¾¹`ã€‚é€šè¿‡æ„é€ Gçš„**å½’çº¦å›¾** ï¼Œå¯ä»¥å±•ç¤ºå„å¼ºåˆ†é‡é—´çš„è”ç³»ã€‚å½’çº¦å›¾ä¸­æ¯ä¸ªå¼ºåˆ†é‡ç”¨ä¸€ä¸ªé¡¶ç‚¹è¡¨ç¤ºï¼Œæ˜¾ç„¶ï¼Œå½’çº¦å›¾ä¸­ä¸å­˜åœ¨ç¯è·¯ã€‚

![image\_1be5jh3nv9jvhddi7ddo11v3t9.png-16.1kB](http://static.zybuluo.com/va-chester/rjc2kop20xg77izsd3elgvnf/image_1be5jh3nv9jvhddi7ddo11v3t9.png)

`Kosaraju`ç®—æ³•æ­¥éª¤ï¼š

* å¯¹æœ‰å‘å›¾ G è¿›è¡Œæ·±åº¦ä¼˜å…ˆæœç´¢å¹¶ä¸”å¯¹é¡¶ç‚¹è¿›è¡Œ**é€†ç¼–å·**\(å³è®°å½•å®ƒä»¬çš„ç¦»å¼€æ—¶é—´\)ã€‚
* å°† G ä¸­çš„æ¯æ¡è¾¹å–åæ–¹å‘ï¼Œæ„é€ ä¸€ä¸ªæ–°æœ‰å‘å›¾ Grã€‚
* æ ¹æ®å‰é¢çš„ç¼–å·ï¼Œä»ç¼–å·æœ€å¤§çš„é¡¶ç‚¹å¼€å§‹å¯¹ Gï¼Œè¿›è¡Œä¸€æ¬¡æ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œå‡¡æ˜¯èƒ½åˆ°è¾¾çš„æ‰€æœ‰é¡¶ç‚¹ï¼Œéƒ½å½¢æˆä¸€æ£µæ·±åº¦ä¼˜å…ˆæœç´¢æ ‘ï¼›è‹¥æœ¬æ¬¡æœç´¢æ²¡æœ‰åˆ°è¾¾æ‰€æœ‰é¡¶ç‚¹ï¼Œä»å›¾ä¸­åˆ é™¤è¿™äº›é¡¶ç‚¹åŠç›¸è¿çš„è¾¹ï¼Œç»§ç»­é‡å¤è¯¥åŠ¨ä½œã€‚
* åœ¨ Gr çš„æ·±åº¦ä¼˜å…ˆæ£®æ—ä¸­ï¼Œæ¯æ£µæ ‘å¯¹åº” G çš„ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ã€‚

_**å›¾çš„è¿é€šæ€§åˆ¤æ–­æ–¹æ³•ä¸»è¦æœ‰ï¼šå¹¶æŸ¥é›†ã€`DFS`ã€`BFS`ã€`WARSHALL`ã€‚**_

## âœ å››ã€æœ€çŸ­è·¯å¾„

æœ€çŸ­è·¯å¾„æ ‘ï¼ˆSPTï¼‰ï¼šåœ¨åŠ æƒæœ‰å‘å›¾ä¸­ï¼Œæœ‰ä¸€ä¸ªé¡¶ç‚¹ sï¼Œä»¥ s ä¸ºèµ·ç‚¹çš„æœ€çŸ­è·¯å¾„æ ‘æ˜¯å›¾çš„ä¸€å¹…å­å›¾ï¼ŒåŒ…å« s å’Œä» s åˆ°è¾¾çš„æ‰€æœ‰é¡¶ç‚¹ã€‚è¿™æ£µæ ‘çš„æ ¹ç»“ç‚¹æ˜¯ sï¼Œæ ‘çš„æ¯æ¡è·¯å¾„éƒ½æ˜¯æœ‰å‘å›¾ä¸­çš„ä¸€æ¡æœ€çŸ­è·¯å¾„ã€‚

### ğŸ–‹ 1ã€`Dijkstra`

Dijkstraå•æºæœ€çŸ­è·¯å¾„ç®—æ³•ï¼Œå³è®¡ç®—ä»èµ·ç‚¹å‡ºå‘åˆ°æ¯ä¸ªç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚æ‰€ä»¥Dijkstraå¸¸å¸¸ä½œä¸ºå…¶ä»–ç®—æ³•çš„é¢„å¤„ç†ï¼Œä½¿ç”¨é‚»æ¥çŸ©é˜µçš„æ—¶é—´å¤æ‚åº¦ä¸º $$O(n^2)$$ ï¼Œç”¨ä¼˜å…ˆé˜Ÿåˆ—çš„å¤æ‚åº¦ä¸º $$O((m+n)logn)$$ ï¼Œè¿‘ä¼¼ä¸º $$O(mlogn)$$ ã€‚

åŸºæœ¬æ€æƒ³ï¼šæ¯æ¬¡æ‰¾åˆ°ç¦»æºç‚¹ï¼ˆå¦‚1å·ç»“ç‚¹ï¼‰æœ€è¿‘çš„ä¸€ä¸ªé¡¶ç‚¹ï¼Œç„¶åä»¥è¯¥é¡¶ç‚¹ä¸ºä¸­å¿ƒè¿›è¡Œæ‰©å±•ï¼Œæœ€ç»ˆå¾—åˆ°æºç‚¹åˆ°å…¶ä½™æ‰€æœ‰ç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚ 

åŸºæœ¬æ­¥éª¤ï¼š

1. è®¾ç½®æ ‡è®°æ•°ç»„`book[]`ï¼šå°†æ‰€æœ‰çš„é¡¶ç‚¹åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œå·²çŸ¥æœ€çŸ­è·¯å¾„çš„é¡¶ç‚¹é›†åˆ P å’ŒæœªçŸ¥æœ€çŸ­è·¯å¾„çš„é¡¶ç‚¹é›†åˆ Qï¼Œå¾ˆæ˜¾ç„¶æœ€å¼€å§‹é›†åˆ P åªæœ‰æºç‚¹ä¸€ä¸ªé¡¶ç‚¹ã€‚ $$book[i]$$ ä¸º 1 è¡¨ç¤ºåœ¨é›†åˆ P ä¸­ï¼› 
2. è®¾ç½®æœ€çŸ­è·¯å¾„æ•°ç»„ $$dst[]$$ å¹¶ä¸æ–­æ›´æ–°ï¼šåˆå§‹çŠ¶æ€ä¸‹ï¼Œä»¤ $$dst[i] = edge[s][i]$$ ï¼Œå¾ˆæ˜¾ç„¶æ­¤æ—¶ $$dst[s]=0$$ ï¼Œ $$book[s]=1$$ ã€‚æ­¤æ—¶ï¼Œåœ¨é›†åˆ Q ä¸­å¯é€‰æ‹©ä¸€ä¸ªç¦»æºç‚¹ s æœ€è¿‘çš„é¡¶ç‚¹ u åŠ å…¥åˆ° P ä¸­ã€‚å¹¶ä¾æ®ä»¥uä¸ºæ–°çš„ä¸­å¿ƒç‚¹ï¼Œå¯¹æ¯ä¸€æ¡è¾¹è¿›è¡Œæ¾å¼›æ“ä½œ\(æ¾å¼›æ˜¯æŒ‡ç”±ç»“ç‚¹ $$s->j$$ çš„é€”ä¸­å¯ä»¥ç»è¿‡ç‚¹ uï¼Œå¹¶ä»¤ $$dst[j]=min\{dst[j], dst[u]+edge[u][j]\}$$ \)ï¼Œå¹¶ä»¤ $$book[u]=1$$ ï¼›
3. åœ¨é›†åˆ Q ä¸­å†æ¬¡é€‰æ‹©ä¸€ä¸ªç¦»æºç‚¹ s æœ€è¿‘çš„é¡¶ç‚¹ v åŠ å…¥åˆ° P ä¸­ã€‚å¹¶ä¾æ® v ä¸ºæ–°çš„ä¸­å¿ƒç‚¹ï¼Œå¯¹æ¯ä¸€æ¡è¾¹è¿›è¡Œæ¾å¼›æ“ä½œ\(å³ $$dst[j]=min\{dst[j], dst[v]+edge[v][j]\}$$ \)ï¼Œå¹¶ä»¤ $$book[v]=1$$ ï¼›
4. é‡å¤3ï¼Œç›´è‡³é›†åˆ Q ä¸ºç©ºã€‚ï¼ˆ[é¢˜ç›®é“¾æ¥](http://hihocoder.com/problemset/problem/1081#)ï¼‰

```cpp
#include <vector>
#include <iostream>
using namespace std;

const int MAX_LEN = 10001;

// æœ€çŸ­è·¯å¾„é•¿åº¦ Dijkstra
void Dijkstra(int N, int S, vector<int>& dst, vector<vector<int>>& graph){
    vector<bool> book(N + 1, false);
    book[S] = true;
    for(int i = 1; i <= N; ++i)
        dst[i] = graph[S][i];
    dst[S] = 0;
    // è¿­ä»£ N - 1 æ¬¡
    for(int i = 1; i < N ; ++i){
        int u = S;
        int tmp = MAX_LEN;
        // æ‰¾ u
        for(int j = 1; j <= N; ++j){
            if(!book[j] && tmp > dst[j]){
                tmp = dst[u = j];
            }
        }
        if(tmp == MAX_LEN)
			      break;	
        // æ¾å¼›è¾¹
        book[u] = true;
        for(int j = 1; j <= N; ++j){
            if(!book[j] && graph[u][j] != MAX_LEN){
                int d = dst[u] + graph[u][j];
                if(d < dst[j])
                    dst[j] = d;
            }
        }
    }
}

int main(void){
    int N = 0, M = 0, S = 0, T = 0;
    while(cin >> N >> M >> S >> T){
        vector<int> dst(N + 1, MAX_LEN);
        vector<vector<int>> graph(N + 1, vector<int>(N + 1, MAX_LEN));
        int u, v, len;
        while(M-- > 0){
            cin >> u >> v >> len;
            if(len < graph[u][v]){
                graph[u][v] = graph[v][u] = len;
            }
        }
        Dijkstra(N, S, dst, graph);
        cout << dst[T] << endl;
    }
    return 0;
}
```

### ğŸ–‹ 2ã€`SPFA`ï¼ˆbellman-fordï¼‰

`SPFA`æ˜¯bellman-fordçš„æ”¹è¿›ç®—æ³•\(é˜Ÿåˆ—å®ç°ï¼‰ï¼Œæ•ˆç‡ä¹Ÿæ›´é«˜ï¼Œæ•…ç›´æ¥ä»‹ç»`SPFA`ã€‚ ç›¸æ¯”äº`Dijkstra`ï¼Œ`SPFA`å¯ä»¥è®¡ç®—å¸¦è´Ÿç¯çš„å›è·¯ã€‚ é‚»æ¥è¡¨çš„å¤æ‚åº¦ä¸ºï¼š $$O(kE)$$ ã€‚E ä¸ºè¾¹æ•°ï¼Œk ä¸€èˆ¬ä¸º2æˆ–3ã€‚

bellman-fordç®—æ³•çš„åŸºæœ¬æ€æƒ³æ˜¯ï¼Œå¯¹å›¾ä¸­é™¤äº†æºé¡¶ç‚¹ s å¤–çš„ä»»æ„é¡¶ç‚¹ uï¼Œä¾æ¬¡æ„é€ ä» s åˆ° u çš„æœ€çŸ­è·¯å¾„é•¿åº¦åºåˆ— $$dist[u], dis2[u], \ldots, dis(n-1)[u]$$ ï¼Œå…¶ä¸­ n æ˜¯å›¾ G çš„é¡¶ç‚¹æ•°ï¼Œ`dis1[u]`æ˜¯ä» s åˆ° u çš„åªç»è¿‡ 1æ¡è¾¹çš„æœ€çŸ­è·¯å¾„é•¿åº¦ï¼Œ`dis2[u]`æ˜¯ä» s åˆ° u çš„æœ€å¤šç»è¿‡ G ä¸­2æ¡è¾¹çš„æœ€çŸ­è·¯å¾„é•¿åº¦ï¼Œå½“å›¾ G ä¸­æ²¡æœ‰ä»æºå¯è¾¾çš„è´Ÿæƒå›¾æ—¶ï¼Œä» s åˆ° u çš„æœ€çŸ­è·¯å¾„ä¸Šæœ€å¤šæœ‰ $$n-1$$ æ¡è¾¹ã€‚å› æ­¤ï¼Œ `dist(n-1)[u]`å°±æ˜¯ä» s åˆ° u çš„æœ€çŸ­è·¯å¾„é•¿åº¦ï¼Œæ˜¾ç„¶ï¼Œè‹¥ä»æº s åˆ° u çš„è¾¹é•¿ä¸º $$e(s,u)$$ ï¼Œåˆ™ $$dis1[u]=e(s,u)$$ ã€‚å¯¹äº $$k>1$$ ï¼Œ`dis(k)[u]`æ»¡è¶³å¦‚ä¸‹é€’å½’å¼ï¼Œ $$dis(k)[u]=min\{dis(k-1)[v]+e(v,u)\}$$ ã€‚bellman-fordæœ€çŸ­è·¯å¾„å°±æ˜¯æŒ‰ç…§è¿™ä¸ªé€’å½’å¼è®¡ç®—æœ€çŸ­è·¯çš„ã€‚ 

`SPFA`çš„å®ç°å¦‚ä¸‹ï¼šç”¨æ•°ç»„disè®°å½•æ›´æ–°åçš„çŠ¶æ€ï¼Œ`cnt`è®°å½•æ›´æ–°çš„æ¬¡æ•°ï¼Œé˜Ÿåˆ— q è®°å½•æ›´æ–°è¿‡çš„é¡¶ç‚¹ï¼Œç®—æ³•ä¾æ¬¡ä» q ä¸­å–å‡ºå¾…æ›´æ–°çš„é¡¶ç‚¹ vï¼ŒæŒ‰ç…§ $$dis(k)[u]$$ çš„é€’å½’å¼è®¡ç®—ã€‚åœ¨è®¡ç®—è¿‡ç¨‹ä¸­ï¼Œä¸€æ—¦å‘ç°é¡¶ç‚¹ K æœ‰ $$cnt[k]>n$$ ï¼Œè¯´æ˜æœ‰ä¸€ä¸ªä»é¡¶ç‚¹ K å‡ºå‘çš„è´Ÿæƒåœˆï¼Œæ­¤æ—¶æ²¡æœ‰æœ€çŸ­è·¯ï¼Œåº”ç»ˆæ­¢ç®—æ³•ã€‚å¦åˆ™ï¼Œé˜Ÿåˆ—ä¸ºç©ºçš„æ—¶å€™ï¼Œç®—æ³•å¾—åˆ° G çš„å„é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„é•¿åº¦ã€‚

### ğŸ–‹ 3ã€`floyd`

å…¨ç§°`Floyd-Warshall`ã€‚åœ¨ç¦»æ•£æ•°å­¦é‡Œå«åš`Warshall`ç®—æ³•ï¼Œç”¨æ¥è®¡ç®—ä¼ é€’é—­åŒ…ã€‚è¿™ä¸ªç®—æ³•ç”¨äºæ±‚æ‰€æœ‰ç‚¹å¯¹çš„æœ€çŸ­è·ç¦»ã€‚æ¯”è°ƒç”¨ n æ¬¡`dijkstra`çš„ä¼˜ç‚¹åœ¨äºä»£ç ç®€å•ã€‚ æ—¶é—´å¤æ‚åº¦ä¸º $$O(n^3)$$ ã€‚

## âœ äº”ã€æœ€å°ç”Ÿæˆæ ‘

æœ€å°ç”Ÿæˆæ ‘æœ‰ä¸¤ä¸ªç»å…¸ç®—æ³•ï¼š

* `Prim` ç®—æ³•
* `Kruskal` ç®—æ³•

å¦‚æœä¸€å¹…å›¾æ˜¯éè¿é€šçš„ï¼Œåˆ™åªèƒ½ç”¨è¿™ä¸ªç®—æ³•è®¡ç®—æ‰€æœ‰è¿é€šåˆ†é‡çš„æœ€å°ç”Ÿæˆæ ‘ï¼Œåˆå¹¶åœ¨ä¸€èµ·å«åš**æœ€å°ç”Ÿæˆæ£®æ—**ã€‚è¿˜æœ‰å‡ ç‚¹è¦æ³¨æ„çš„ï¼š

* è¾¹çš„æƒé‡æœªå¿…æ˜¯è·ç¦»ã€‚
* è¾¹çš„æƒé‡å¯èƒ½å°äºç­‰äº 0 ã€‚
* æ‰€æœ‰è¾¹çš„æƒé‡éƒ½å¯èƒ½ç›¸åŒä¹Ÿå¯èƒ½ä¸ç›¸åŒã€‚

ä¸¤ä¸ªæ€§è´¨ï¼š

* ç”¨ä¸€æ¡è¾¹è¿æ¥æ ‘ä¸­çš„ä»»æ„ä¸¤ä¸ªé¡¶ç‚¹éƒ½ä¼šäº§ç”Ÿä¸€ä¸ªæ–°çš„ç¯ã€‚
* ä»æ ‘ä¸­åˆ å»ä¸€æ¡è¾¹å¯ä»¥å¾—åˆ°ä¸¤æ£µç‹¬ç«‹çš„æ ‘ã€‚ ![&#x8FD9;&#x91CC;&#x5199;&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://algs4.cs.princeton.edu/43mst/images/tree-add-edge.png)

å›¾çš„ä¸€ç§åˆ‡åˆ†æ˜¯æŠŠå›¾çš„æ‰€æœ‰é¡¶ç‚¹åˆ†ä¸ºä¸¤ä¸ª éç©º ä¸” ä¸é‡å¤ çš„é›†åˆã€‚æ¨ªåˆ‡ç‰‡æ˜¯ä¸€æ¡è¿æ¥ä¸¤ä¸ªå±äºä¸åŒé›†åˆçš„è¾¹ã€‚é€šå¸¸ï¼Œæˆ‘ä»¬æŒ‡å®šä¸€ä¸ªé¡¶ç‚¹é›†ï¼Œç„¶åéšå¼åœ°è®¤ä¸ºå®ƒçš„è¡¥é›†æ˜¯å¦ä¸€ä¸ªé¡¶ç‚¹é›†ã€‚ç»™å®šä»»æ„çš„åˆ‡åˆ†ï¼Œå®ƒçš„æ¨ªåˆ‡è¾¹ä¸­çš„æƒé‡æœ€å°è€…å¿…ç„¶å±äºå›¾çš„æœ€å°ç”Ÿæˆæ ‘ã€‚å‡è®¾æ‰€æœ‰è¾¹çš„æƒé‡ä¸ç›¸åŒï¼Œåˆ™æ¯å¹…è¿é€šå›¾éƒ½åªæœ‰å”¯ä¸€çš„æœ€å°ç”Ÿæˆæ ‘ã€‚

### \*\*\*\*ğŸ–‹ 1ã€**Primç®—æ³•**

Primç®—æ³•èƒ½å¤Ÿå¾—åˆ°ä»»æ„åŠ æƒæ— å‘å›¾çš„æœ€å°ç”Ÿæˆæ ‘ã€‚æ¯ä¸€æ­¥éƒ½ä¼šä¸ºæˆé•¿ä¸­çš„æ ‘åŠ ä¸€æ¡è¾¹ã€‚

Lazyå®ç°ï¼š

![&#x8FD9;&#x91CC;&#x5199;&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://algs4.cs.princeton.edu/43mst/images/prim-lazy.png)

* é¦–å…ˆåˆå§‹åŒ–æƒé‡çŸ©é˜µï¼›
* åˆå§‹åŒ–èµ·å§‹ç‚¹åˆ°å¯è¾¾é¡¶ç‚¹çš„è·ç¦»æ•°ç»„ï¼Œå¹¶æ ‡è®°èµ·å§‹ç‚¹å·²è®¿é—®ï¼Œæ‰¾å‡ºèµ·å§‹ç‚¹åˆ°å¯è¾¾ç»“ç‚¹çš„ä»£ä»·æœ€å°çš„è¾¹ï¼Œå°†è¿™ä¸ªè¾¹åŠ å…¥ sumï¼Œè¿™æ¡è¾¹å¯¹åº”ä¸€ä¸ªå¯è¾¾é¡¶ç‚¹ï¼Œè®¾ç½®è¿™ä¸ªé¡¶ç‚¹å·²è®¿é—®`visited[pos] = true`ã€‚
* å†åˆ° graph ä¸­å»æ‰¾è¯¥é¡¶ç‚¹å¯è¾¾çš„é¡¶ç‚¹ï¼ˆæœªè¢«è®¿é—®ä¸”å½“å‰è·ç¦»å¤§äºæ–°çš„è·ç¦»ï¼›`!visited[i] && distance[i] > G[pos][i]`ï¼‰ï¼Œé‚£ä¹ˆæ›´æ–°è¿™ä¸ªå½“å‰è·ç¦»ï¼ˆå› ä¸ºè¦å–ä»£ä»·å°çš„è¾¹ï¼‰ï¼Œå¦åˆ™ä¸æ›´æ–°ï¼›
* ç”±äºé™¤å»èµ·å§‹ç‚¹æœ¬èº«ï¼Œæ‰€ä»¥å¾ªç¯ `N - 1` æ¬¡ã€‚ï¼ˆ[é¢˜ç›®é“¾æ¥](http://hihocoder.com/problemset/problem/1097?sid=1402285)ï¼‰

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int MAX_LEN = 100001;

int Prim(int N, std::vector<int>& dst, std::vector<std::vector<int>>& graph){
    vector<bool> visited(N + 1, false);
    visited[1] = true;
    for(int i = 1; i <= N; ++i) {
        dst[i] = graph[1][i];
    }
    int result = 0;
    for(int i = 1; i < N; ++i){
        int tmp = MAX_LEN;
        int u = 1;
        for(int j = 1; j <= N; ++j){
            if(!visited[j] && tmp > dst[j]){
                tmp = dst[u = j];
            }
        }
        if(tmp == MAX_LEN)
            break;
        visited[u] = true;
        result += tmp;
        for(int j = 1; j <= N; ++j){
            if(!visited[j] && dst[j] > graph[u][j]){
                dst[j] = graph[u][j];
            }
        }
    }
    return result;
}

int main(){
    int N = 0;
    while(cin >> N){
        int val = 0;
        vector<vector<int>> graph(N + 1, vector<int>(N + 1, MAX_LEN));
        for(int i = 1; i <= N; ++i){
            for(int j = 1; j <= N; ++j){
                cin >> val;
                graph[i][j] = val;
            }
        }
        vector<int> dst(N + 1, MAX_LEN);
        cout << Prim(N, dst, graph) << endl;
    }
    return 0;
}
```

Eagerå®ç°ï¼š

![&#x8FD9;&#x91CC;&#x5199;&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://algs4.cs.princeton.edu/43mst/images/prim-eager.png)

### \*\*\*\*ğŸ–‹ 2ã€**`Kruskal` ç®—æ³•**

`Kruskal` ç®—æ³•çš„æ€æƒ³æ˜¯æŒ‰ç…§è¾¹çš„æƒé‡é¡ºåºï¼ˆä»å°åˆ°å¤§ï¼‰åŠ å…¥åˆ°æ ‘ä¸­ï¼ŒåŠ å…¥çš„è¾¹ä¸ä¼šæ„æˆç¯ã€‚

![&#x8FD9;&#x91CC;&#x5199;&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://algs4.cs.princeton.edu/43mst/images/kruskal.png)

ï¼ˆ[é¢˜ç›®é“¾æ¥](http://hihocoder.com/problemset/problem/1098?sid=1584302)ï¼‰

{% tabs %}
{% tab title="c++14" %}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
#include <memory>

using namespace std;

struct Edge{
    int st;
    int ed;
    int cost;
    Edge(int s, int e, int c) : st(s), ed(e), cost(c) {}
};

int Kruscal(std::vector<int>& trees, std::vector<Edge>& graph){
    int result = 0;
    auto recursiveFunc = 
                  std::make_shared<std::unique_ptr< std::function<int(int)> >>();
    *recursiveFunc = std::make_unique<std::function<int(int)>>(
        [=, &trees] (int a){
            return a == trees[a] ? a : (trees[a] = (**recursiveFunc)(trees[a]));
        }
    );
    for(auto edge : graph){
        if((**recursiveFunc)(edge.st) != (**recursiveFunc)(edge.ed)){
            result += edge.cost;
            trees[(**recursiveFunc)(edge.st)] = (**recursiveFunc)(edge.ed);
        }
    }
    return result;
}

int main(){
    int N = 0, M = 0;
    int N1, N2, V;
    while(cin >> N >> M){
        vector<Edge> graph;
        while(M-- > 0){
            cin >> N1 >> N2 >> V;
            Edge edge(N1, N2, V);
            graph.push_back(edge);
        }
        // æ’åº
        sort(graph.begin(), graph.end(), 
             [](const Edge& a, const Edge& b)->bool {return a.cost < b.cost; });
        vector<int> root(N + 1);
        for(int i = 1; i <= N; ++i){
            root[i] = i;
        }
        cout << Kruscal(root, graph) << endl;
    }
    return 0;
}
```
{% endtab %}

{% tab title="c++11" %}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
#include <memory>

using namespace std;

struct Edge{
    int st;
    int ed;
    int cost;
    Edge(int s, int e, int c) : st(s), ed(e), cost(c) {}
};

int Kruscal(std::vector<int>& trees, std::vector<Edge>& graph){
    int result = 0;
    auto recursiveFunc = std::shared_ptr<std::unique_ptr< std::function<int(int)> >>
                         (new std::unique_ptr< std::function<int(int)> >());
    *recursiveFunc = std::unique_ptr<std::function<int(int)>>( 
        new std::function<int(int)>(
            [=, &trees] (int a){
                return a == trees[a] ? a : (trees[a] = (**recursiveFunc)(trees[a]));
            }
        )
    );
    for(auto edge : graph){
        if((**recursiveFunc)(edge.st) != (**recursiveFunc)(edge.ed)){
            result += edge.cost;
            trees[(**recursiveFunc)(edge.st)] = (**recursiveFunc)(edge.ed);
        }
    }
    return result;
}

int main(){
    int N = 0, M = 0;
    int N1, N2, V;
    while(cin >> N >> M){
        vector<Edge> graph;
        while(M-- > 0){
            cin >> N1 >> N2 >> V;
            Edge edge(N1, N2, V);
            graph.push_back(edge);
        }
        // æ’åº
        sort(graph.begin(), graph.end(), 
             [](const Edge& a, const Edge& b)->bool {return a.cost < b.cost; });
        vector<int> root(N + 1);
        for(int i = 1; i <= N; ++i){
            root[i] = i;
        }
        cout << Kruscal(root, graph) << endl;
    }
    return 0;
}
```
{% endtab %}

{% tab title="å¸¸è§„æ“ä½œ" %}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Edge{
    int st;
    int ed;
    int cost;
    Edge(int s, int e, int c) : st(s), ed(e), cost(c) {}
};

int Find(std::vector<int>& pre, int x){
    return x == pre[x] ? x : pre[x] = Find(pre, pre[x]);
}

void Union(std::vector<int>& pre, int x,int y){
    pre[Find(pre, x)] = Find(pre, y);
}

int Kruscal(std::vector<int>& trees, std::vector<Edge>& graph){
    int result = 0;
    for(auto edge : graph){
        if(Find(trees, edge.st) != Find(trees, edge.ed)){
            result += edge.cost;
            Union(trees, edge.st, edge.ed);
        }
    }
    return result;
}

int main(){
    int N = 0, M = 0;
    int N1, N2, V;
    while(cin >> N >> M){
        vector<Edge> graph;
        while(M-- > 0){
            cin >> N1 >> N2 >> V;
            Edge edge(N1, N2, V);
            graph.push_back(edge);
        }
        // æ’åº
        sort(graph.begin(), graph.end(), 
             [](const Edge& a, const Edge& b)->bool {return a.cost < b.cost; });
        vector<int> root(N + 1);
        for(int i = 1; i <= N; ++i){
            root[i] = i;
        }
        cout << Kruscal(root, graph) << endl;
    }
    return 0;
}
```
{% endtab %}
{% endtabs %}

## âœ å…­ã€æ‹“æ‰‘æ’åºã€[é“¾æ¥](https://leetcode-cn.com/problems/course-schedule/)ã€‘

å¯¹ä¸€ä¸ª**æœ‰å‘æ— ç¯å›¾**ï¼ˆ`Directed Acyclic Graph`ç®€ç§°DAGï¼‰Gè¿›è¡Œæ‹“æ‰‘æ’åºï¼Œæ˜¯å°†Gä¸­æ‰€æœ‰é¡¶ç‚¹æ’æˆä¸€ä¸ªçº¿æ€§åºåˆ—ï¼Œä½¿å¾—å›¾ä¸­ä»»æ„ä¸€å¯¹é¡¶ç‚¹uå’Œvï¼Œè‹¥è¾¹ $$<u,v>âˆˆE(G)$$ ï¼Œåˆ™uåœ¨çº¿æ€§åºåˆ—ä¸­å‡ºç°åœ¨vä¹‹å‰ã€‚é€šå¸¸ï¼Œè¿™æ ·çš„çº¿æ€§åºåˆ—ç§°ä¸ºæ»¡è¶³æ‹“æ‰‘æ¬¡åºï¼ˆTopological Orderï¼‰çš„åºåˆ—ï¼Œç®€ç§°æ‹“æ‰‘åºåˆ—ã€‚ç®€å•çš„è¯´ï¼Œç”±æŸä¸ªé›†åˆä¸Šçš„ä¸€ä¸ªååºå¾—åˆ°è¯¥é›†åˆä¸Šçš„ä¸€ä¸ªå…¨åºï¼Œè¿™ä¸ª**æ“ä½œç§°ä¹‹ä¸ºæ‹“æ‰‘æ’åº**ã€‚

æœ‰å‘å›¾çš„æ‹“æ‰‘æ’åºçš„åŸºæœ¬æ€æƒ³æ˜¯ï¼šé¦–å…ˆåœ¨æœ‰å‘å›¾ä¸­é€‰å–ä¸€ä¸ªæ²¡æœ‰å‰é©±ï¼ˆå…¥åº¦ä¸º0ï¼‰çš„é¡¶ç‚¹ï¼Œå°†å…¶è¾“å‡ºï¼Œä»æœ‰å‘å›¾ä¸­åˆ é™¤è¯¥é¡¶ç‚¹ï¼Œå¹¶ä¸”åˆ é™¤ä»¥è¯¥é¡¶ç‚¹ä¸ºå°¾çš„æ‰€æœ‰æœ‰å‘å›¾çš„è¾¹ã€‚é‡å¤ä»¥ä¸Šçš„æ­¥éª¤ï¼Œç›´åˆ°å›¾ä¸­çš„æ‰€æœ‰é¡¶ç‚¹å‡è¾“å‡ºæˆ–æ˜¯å›¾ä¸­çš„é¡¶ç‚¹å‡æ²¡æœ‰å‰é©±ä¸ºæ­¢ã€‚å¯¹äºåè€…ï¼Œè¯´æ˜æœ‰å‘å›¾ä¸­å­˜åœ¨ç¯ï¼Œä¸èƒ½è¿›è¡Œæ‹“æ‰‘æ’åºã€‚

### ğŸ–‹ 1ã€`BFS`

`BFS`ç®—æ³•åˆç§°`Kahn`ç®—æ³•ï¼Œè¯¥ç®—æ³•éœ€è¦ç»´æŠ¤ä¸€ä¸ªå…¥åº¦ä¸º0çš„é¡¶ç‚¹çš„é›†åˆï¼Œæ¯æ¬¡ä»è¯¥é›†åˆä¸­å–å‡ºï¼ˆæ²¡æœ‰ç‰¹æ®Šçš„å–å‡ºè§„åˆ™ï¼Œéšæœºå–å‡ºä¹Ÿè¡Œï¼Œä½¿ç”¨é˜Ÿåˆ—/æ ˆä¹Ÿè¡Œï¼Œä¸‹åŒï¼‰ä¸€ä¸ªé¡¶ç‚¹ï¼Œå°†è¯¥é¡¶ç‚¹æ”¾å…¥ç»“æœåºåˆ—ä¸­ã€‚ç´§æ¥ç€å¾ªç¯éå†ç”±è¯¥é¡¶ç‚¹å¼•å‡ºçš„æ‰€æœ‰è¾¹ï¼Œä»å›¾ä¸­ç§»é™¤è¿™æ¡è¾¹ï¼ŒåŒæ—¶è·å–è¯¥è¾¹çš„å¦å¤–ä¸€ä¸ªé¡¶ç‚¹ï¼Œå¦‚æœè¯¥é¡¶ç‚¹çš„å…¥åº¦åœ¨å‡å»æœ¬æ¡è¾¹ä¹‹åä¸º0ï¼Œé‚£ä¹ˆä¹Ÿå°†è¿™ä¸ªé¡¶ç‚¹æ”¾åˆ°å…¥åº¦ä¸º0çš„é›†åˆä¸­ã€‚ç„¶åç»§ç»­ä»é›†åˆä¸­å–å‡ºä¸€ä¸ªå…¥åº¦ä¸º0çš„é¡¶ç‚¹ï¼Œé‡å¤ä¸Šè¿°çš„æ“ä½œã€‚å½“é›†åˆä¸ºç©ºä¹‹åï¼Œæ£€æŸ¥å›¾ä¸­æ˜¯å¦è¿˜å­˜åœ¨ä»»ä½•è¾¹ï¼Œå¦‚æœå­˜åœ¨çš„è¯ï¼Œè¯´æ˜å›¾ä¸­è‡³å°‘å­˜åœ¨ä¸€æ¡ç¯è·¯ã€‚ä¸å­˜åœ¨çš„è¯åˆ™è¿”å›ç»“æœListï¼Œæ­¤Listä¸­çš„é¡ºåºå°±æ˜¯å¯¹å›¾è¿›è¡Œæ‹“æ‰‘æ’åºçš„ç»“æœã€‚

```cpp
std::vector<int> topologicalSort_bfs(int n, std::vector<std::pair<int, int> >& edges){
    vector<int> res;
    queue<int> iqueue;
    int in_degree[n];
    memset(in_degree, 0, sizeof in_degree);
    for(auto edge : edges){
        in_degree[edge.second]++;
    }
    for(int i = 0; i < n; ++i){
        if(in_degree[i] == 0)
            iqueue.push(i);
    }
    while(!iqueue.empty()){
        int tmp = iqueue.front();
        iqueue.pop();
        res.push_back(tmp);
        for(int i = 0; i < edges.size(); ++i){
            if(edges[i].first == tmp){
                in_degree[edges[i].second]--;
                if(in_degree[edges[i].second] == 0)
                    iqueue.push(edges[i].second);
            }
        }
    }
    return res.size() == n ? res : vector<int>();
}
```

### ğŸ–‹ 2ã€`DFS`

åˆ©ç”¨`DFS`å®ç°æ‹“æ‰‘æ’åºï¼Œéœ€è¦ä½¿ç”¨æ ˆç»“æ„æ¥ç»´æŠ¤ä¸€ä¸ªå‡ºåº¦ä¸º0çš„é¡¶ç‚¹çš„é›†åˆã€‚æ·»åŠ é¡¶ç‚¹åˆ°ç»“æœé›†ä¸­çš„æ—¶æœºæ˜¯åœ¨`DFS`æ–¹æ³•å³å°†é€€å‡ºä¹‹æ—¶ï¼Œ`DFS`æ–¹æ³•æœ¬èº«æ˜¯ä¸ªé€’å½’æ–¹æ³•ï¼Œåªè¦å½“å‰é¡¶ç‚¹è¿˜å­˜åœ¨è¾¹æŒ‡å‘å…¶å®ƒä»»ä½•é¡¶ç‚¹ï¼Œå®ƒå°±ä¼šé€’å½’è°ƒç”¨`DFS`æ–¹æ³•ï¼Œè€Œä¸ä¼šé€€å‡ºã€‚å› æ­¤ï¼Œé€€å‡º`DFS`æ–¹æ³•ï¼Œæ„å‘³ç€å½“å‰é¡¶ç‚¹æ²¡æœ‰æŒ‡å‘å…¶å®ƒé¡¶ç‚¹çš„è¾¹äº†ï¼Œå³å½“å‰é¡¶ç‚¹æ˜¯ä¸€æ¡è·¯å¾„ä¸Šçš„æœ€åä¸€ä¸ªé¡¶ç‚¹ã€‚

```cpp
void dfs(vector<vector<int> >&v, stack<int> &s, int *isVisited, int u, bool &isCircled){
    if(isCircled)
        return;
    isVisited[u] = -1;
    for(int i = 0; i < v[u].size(); ++i){
        if (isVisited[v[u][i]] == 0) {
            dfs(v, s, isVisited, v[u][i], isCircled);
        }else if(isVisited[v[u][i]] == -1){
            isCircled = true;
            return;
        }
    }
    isVisited[u] = 1;
    s.push(u);
}
std::vector<int> topologicalSort_dfs(int n, std::vector<std::pair<int, int> >& edges){
    vector<int> res;
    stack<int> istack;
    int isVisited[n]; // 0ä¸ºæœªè®¿é—®ï¼Œ1ä¸ºå·²è®¿é—®ï¼Œ-1ä¸ºæ­£åœ¨è®¿é—®ï¼Œå½“dfsæœç´¢æ—¶é‡åˆ°äº†
                      // ä¸€æ¡è¾¹ç»ˆæ­¢é¡¶ç‚¹å¯¹åº”çš„isVisitedå…ƒç´ ä¸º-1æ—¶ï¼Œå°±è¯´æ˜å›¾ä¸­æœ‰ç¯äº†
    memset(isVisited, 0, sizeof isVisited);
    vector<vector<int> > v_edges(n);
    for(auto edge : edges) {
        v_edges[edge.second].push_back(edge.first);
    }
    bool isCircled = false;
    for(int i = 0; i < n; ++i){
        if(!isVisited[i])
            dfs(v_edges, istack, isVisited, i, isCircled);
        if(isCircled)
            break;
    }
    if (isCircled)
        return vector<int>();
    while(!istack.empty()){
        res.push_back(istack.top());
        istack.pop();
    }
    return res;
}
```

#### **ä¸¤ç§å®ç°ç®—æ³•çš„æ€»ç»“ï¼š**

è¿™ä¸¤ç§ç®—æ³•åˆ†åˆ«ä½¿ç”¨é“¾è¡¨å’Œæ ˆæ¥è¡¨ç¤ºç»“æœé›†ã€‚å¯¹äºåŸºäºDFSçš„ç®—æ³•ï¼ŒåŠ å…¥ç»“æœé›†çš„æ¡ä»¶æ˜¯ï¼šé¡¶ç‚¹çš„å‡ºåº¦ä¸º0ã€‚è€ŒKahnç®—æ³•ä¸­å…¥åº¦ä¸º0çš„é¡¶ç‚¹é›†åˆä¸ºç»“æœé›†ã€‚ä¸€ä¸ªæ˜¯ä»å…¥åº¦çš„è§’åº¦æ¥æ„é€ ç»“æœé›†ï¼Œå¦ä¸€ä¸ªåˆ™æ˜¯ä»å‡ºåº¦çš„è§’åº¦æ¥æ„é€ ã€‚äºŒè€…çš„å¤æ‚åº¦å‡ä¸º $$O(V+E)$$ ã€‚

#### **å®ç°ä¸Šçš„ä¸€äº›ä¸åŒä¹‹å¤„ï¼š**

Kahnç®—æ³•ä¸éœ€è¦æ£€æµ‹å›¾ä¸ºDAGï¼Œå¦‚æœå›¾ä¸ºDAGï¼Œé‚£ä¹ˆåœ¨å‡ºåº¦ä¸º0çš„é›†åˆä¸ºç©ºä¹‹åï¼Œå›¾ä¸­è¿˜å­˜åœ¨æ²¡æœ‰è¢«ç§»é™¤çš„è¾¹ï¼Œè¿™å°±è¯´æ˜äº†å›¾ä¸­å­˜åœ¨ç¯è·¯ã€‚è€ŒåŸºäºDFSçš„ç®—æ³•éœ€è¦é¦–å…ˆç¡®å®šå›¾ä¸ºDAGï¼Œå½“ç„¶ä¹Ÿèƒ½å¤Ÿåšå‡ºé€‚å½“è°ƒæ•´ï¼Œè®©ç¯è·¯çš„æ£€æµ‹å’Œæ‹“æ‰‘æ’åºåŒæ—¶è¿›è¡Œï¼Œæ¯•ç«Ÿç¯è·¯æ£€æµ‹ä¹Ÿèƒ½å¤Ÿåœ¨DFSçš„åŸºç¡€ä¸Šè¿›è¡Œã€‚ï¼ˆä¸Šè¿°ä»£ç ä¹Ÿæ˜¯è¿™æ ·åšçš„ï¼‰

### ğŸ–‹ 3ã€é¢˜å‹

\*\*\*\*[**Course Schedule**](https://leetcode-cn.com/problems/course-schedule/)\*\*\*\*

```cpp
bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
    vector<int> res;
    queue<int> iqueue;
    int in_degree[numCourses];
    memset(in_degree, 0, sizeof in_degree);
    for(auto edge : prerequisites){
        in_degree[edge[1]]++;
    }
    for(int i = 0; i < numCourses; ++i){
        if(in_degree[i] == 0)
            iqueue.push(i);
    }
    while(!iqueue.empty()){
        int tmp = iqueue.front();
        iqueue.pop();
        res.push_back(tmp);
        for(int i = 0; i < prerequisites.size(); ++i){
            if(prerequisites[i][0] == tmp){
                in_degree[prerequisites[i][1]]--;
                if(in_degree[prerequisites[i][1]] == 0)
                    iqueue.push(prerequisites[i][1]);
            }
        }
    }
    return res.size() == numCourses ? true : false;
}
```

#### [Course Schedule II](https://leetcode-cn.com/problems/course-schedule-ii/) 

```cpp
void dfs(vector<vector<int> >&v, stack<int> &s, int *isVisited, int u, bool &isCircled){
    if(isCircled)
        return;
    isVisited[u] = -1;
    for(int i = 0; i < v[u].size(); ++i){
        if (isVisited[v[u][i]] == 0) {
            dfs(v, s, isVisited, v[u][i], isCircled);
        }else if(isVisited[v[u][i]] == -1){
            isCircled = true;
            return;
        }
    }
    isVisited[u] = 1;
    s.push(u);
}
vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
    vector<int> res;
    stack<int> istack;
    int isVisited[numCourses]; 
    memset(isVisited, 0, sizeof isVisited);
    vector<vector<int> > v_edges(numCourses);
    for(auto edge : prerequisites) {
        v_edges[edge[1]].push_back(edge[0]);
    }
    bool isCircled = false;
    for(int i = 0; i < numCourses; ++i){
        if(!isVisited[i])
            dfs(v_edges, istack, isVisited, i, isCircled);
        if(isCircled)
            break;
    }
    if (isCircled)
        return vector<int>();
    while(!istack.empty()){
        res.push_back(istack.top());
        istack.pop();
    }
    return res;
}
```

#### [Longest Increasing Path in a Matrix](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)

## âœ ä¸ƒã€ä¾‹é¢˜

### [Clone Graph](http://blog.csdn.net/linhuanmars/article/details/22715747)

###  [Word Ladder](http://blog.csdn.net/linhuanmars/article/details/23029973)

###  [Word Ladder II](http://blog.csdn.net/linhuanmars/article/details/23071455)

###  [Longest Consecutive Sequence](http://blog.csdn.net/linhuanmars/article/details/22964467)

###  [Word Search](http://blog.csdn.net/linhuanmars/article/details/24336987)

###  [Surrounded Regions](http://blog.csdn.net/linhuanmars/article/details/22904855)

